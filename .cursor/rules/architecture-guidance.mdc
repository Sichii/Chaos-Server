---
description: Architecture patterns, library organization, and codebase structure guidance for Chaos Server. Use when questions involve project structure, library responsibilities, dependency patterns, service registration, or modular integration. Covers the 20+ specialized libraries, their purposes, and how they interact. Essential for understanding the separation of concerns and adding new features.
globs: 
alwaysApply: false
---
# Architecture & Codebase Understanding

**WHEN TO USE:** Questions about project structure, library organization, dependencies, or architectural decisions.

## ğŸ—ï¸ ARCHITECTURAL PRINCIPLES

1. **Separation of Concerns:** Each library has a specific responsibility
2. **Dependency Injection:** Use existing DI container patterns
3. **Configuration-Driven:** Leverage JSON-based configuration system
4. **Event-Driven:** Use existing event patterns for game interactions
5. **Modular Design:** New features should integrate, not replace

## ğŸ“ CODE ORGANIZATION PATTERNS

```
Chaos.LibraryName/
â”œâ”€â”€ Abstractions/          # Interfaces and base classes
â”œâ”€â”€ Extensions/           # Extension methods
â”œâ”€â”€ Options/             # Configuration classes
â”œâ”€â”€ Definitions/         # Constants and enums
â””â”€â”€ [Specific folders]   # Library-specific organization
```

## ğŸ”§ LIBRARY RESPONSIBILITIES

### Infrastructure Libraries
- **Chaos.Common.Abstractions** â†’ Core abstractions and interfaces
- **Chaos.Extensions.Common** â†’ Shared extension methods
- **Chaos.Extensions.Geometry** â†’ Spatial calculation extensions
- **Chaos.Geometry** â†’ Spatial mathematics and pathfinding

### Core Systems Libraries
- **Chaos.Networking** â†’ TCP client/server infrastructure, packet handling
- **Chaos.Cryptography** â†’ Security and encryption services
- **Chaos.Storage** â†’ Data persistence, caching, backup systems
- **Chaos.Time** â†’ Timing, scheduling, and delta management
- **Chaos.TypeMapper** â†’ Object transformation services

### Game Logic Libraries
- **Chaos.Scripting** â†’ Dynamic script execution system
- **Chaos.Models** â†’ Game entity models (Aislings, Monsters, Items)
- **Chaos.Collections** â†’ Specialized game data collections
- **Chaos.MetaData** â†’ Game metadata and rendering information

### Service Libraries
- **Chaos.Messaging** â†’ Inter-component communication
- **Chaos.Security** â†’ Authentication and authorization
- **Chaos.Pathfinding** â†’ AI movement and navigation

## ğŸ”„ DEPENDENCY PATTERNS

### Service Registration
- Use existing `ServiceCollectionExtensions` patterns
- Register services by library with clear lifetime scopes
- Maintain separation between abstractions and implementations

### Configuration Integration
- Leverage `IOptions<T>` pattern for strongly-typed configuration
- Validate configuration at startup

### Event Handling
- Use existing event patterns for game interactions
- Implement proper event cleanup and disposal
- Consider concurrent access for event handlers

## ğŸ­ FACTORY PATTERNS

### Entity Creation
- Use template-based factory patterns for game entities
- Separate concerns between templates, metadata, and runtime objects
- Support dynamic script attachment during creation

### Service Factories
- Implement factory patterns for complex service initialization
- Use dependency injection for factory dependencies
- Support configuration-driven factory behavior

## ğŸ“¦ MODULAR INTEGRATION

### Adding New Libraries
1. Follow existing naming conventions (`Chaos.NewModule`)
2. Create corresponding abstractions library if needed
3. Implement proper service registration extensions
4. Add appropriate project references and package dependencies

### Cross-Library Communication
- Use abstractions for cross-library dependencies
- Implement proper error handling and logging
- Consider performance implications of cross-library calls

